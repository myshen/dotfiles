source_file_if_exists() {
        if [ -f $1 ]; then
                . $1
#        else
#                echo "Attempted to source non-existant file: $1" >&2;
        fi
}

source_file_if_exists ~/.dotfiles_local/bash-like-common/functions &> /dev/null;

# Path manipulation

path() {
	local path_="$1"
	if [ -z "$path_" ]; then
		path_="PATH"
	fi

        echo -e ${!path_//:/\\n}
}

path_contains() {
        path "$2" | grep -q -e "^$1$"
}

path_rm() {
	# Arguments: path_to_rm [path_variable]
	local rmpath="$1"; shift
	local path_="$1"; shift
	if [ -z "$path_" ]; then
		path_="PATH"
	fi

	local newpath=$(\
		path "$path_" | grep -v -e "^$rmpath$" | grep -v -e "^$" | \
		paste -s -d ":" -)
	eval "$path_=\"$newpath\""
	export "$path_"
}

path_add() {
	# Arguments: path_to_add [prepend] [path_variable]
	local newpath="$1"; shift
	local prepend="$1"; shift
	local path_="$1"; shift
	if [ -z "$prepend" ]; then
		prepend="0"
	fi
	if [ -z "$path_" ]; then
		path_="PATH"
	fi

        local stripped="${!path_}"
	if path_contains $newpath "$path_"; then
                path_rm $newpath "$path_"
                stripped="${!path_}"
	fi
	if [ 0 -ne $prepend ]; then
		stripped="$newpath:${stripped}"
	else
		stripped="${stripped}:$newpath"
	fi
	stripped=${stripped#:%:}
	eval "$path_=\"${stripped//::/:}\""
	export "$path_"
}

path_add_maybe() {
	# Arguments: see path_add, if new path is already in path, noop.
	if ! path_contains $1 $3; then
                path_add $1 $2;
        fi
}

# Assorted
swap() {
	[ $# -ne 2 ] && echo "swap: 2 arguments needed" && return 1

	local TMPFILE=$(mktemp $1.XXXX)
	[ ! -e $1 ] && echo "swap: $1 does not exist" && return 1
	[ ! -e $2 ] && echo "swap: $2 does not exist" && return 1

	'mv' "$1" $TMPFILE && \
	'mv' "$2" "$1" && \
	'mv' $TMPFILE "$2";
}

edsrc() {
	if [ $# -ne 1 ]; then
		echo "Usage: edsrc\nPlease give file(s) to edit" >&2;
	else
		${EDITOR} $1;
		source $1;
	fi
}

# https://github.com/markeganfuller/bashrc/blob/master/bashrc
# Disable crontab -r
crontab() {
	# Replace -r with -e
	/usr/bin/crontab "${@/-r/-e}"
}

# Highlight Pattern
# highlights a pattern in output
# Usage: hlp CMD PATTERN
# commands with args should be in quotes
hlp() {
	CMD=$1
	PATTERN=$2
	${CMD} 2>&1 | egrep --color "${PATTERN}|$"
}

man() {
        /usr/bin/man $@ || (help $@ 2> /dev/null && help $@ | less)
}

pd() {
	if [[ $# -ge 1 ]]; then
		choice="$1"
	else
		dirs -v
		echo -n "? "
		read choice
	fi
	if [[ -n $choice ]];
	then
		declare -i cnum="$choice"
		if [[ $cnum != $choice ]];
		then #choice is not numeric
			choice=$(dirs -v | grep $choice | tail -1 | awk '{print $1}')
			cnum="$choice"
			if [[ -z $choice || $cnum != $choice ]];
			then
				echo "$choice not found"
				return
			fi
		fi
		choice="+$choice"
	fi
	pushd $choice
}

has_screen() {
	python -c 'import sys; sys.exit(1 if sys.argv[1].startswith("There is a screen on:") else 0)' \
		"$(screen -ls | head -n1)";
}

attachOrNewScreen() {
        if [[ ! -f ~/.nomultiplex ]]; then
                if [ 1 -eq $(has_screen; echo $?) ]; then
                        if [[ "${SSH_CONNECTION}" != "" ]]; then
                                screen -dr && exit;
                        else
                                screen -list | grep -q Detached;
                                if [ 0 -eq $? ]; then
                                        screen -dr && exit;
                                fi
                        fi
                else
                        screen && exit;
                fi
        fi
}

attachOrNewTmux() {
        if [[ ! -f ~/.nomultiplex ]]; then
                tmux has &> /dev/null;
                if [ 0 -eq $? ]; then
                        if [ ! -n "${TMUX}" ]; then
                                if [[ "${SSH_CONNECTION}" != "" ]]; then
                                        tmux new-session -t 0 && exit;
                                else
                                        tmux ls | grep -qF "attached";
                                        if [ 0 -ne $? ]; then
                                                tmux attach && exit;
                                        fi
                                fi
                        fi
                else
                        tmux new && exit;
                fi
        fi
}

cd_wd() {
        CDWDCACHE="~/.cd_wd_cache"
        if [[ -e ${CDWDCACHE} ]]; then
                cd $(cat ${CDWDCACHE});
                rm -f ${CDWDCACHE};
        fi
}

mysql_last_deadlock() {
    local mysql="$1"; shift
    if [ -z "$mysql" ]; then
        mysql="lmysql"
    fi
    printf "$(echo "show engine innodb status" | $mysql)" | strings | grep --after-context=999999 "DEADLOCK" | grep --before-context=999999 "WE ROLL BACK TRANSACTION"
}

calc() {
    echo "$@" | bc -l
}

gsvnpush() {
    git stash; git svnr; git svnd && git stash pop
}

tmux_() {
    detached=$(tmux list-sessions \
            -F "#{session_id} #{session_name} #{session_attached}" | \
        grep -v " 1$" | head -n 1 | cut -d " " -f 1
    )
    if [[ "$detached" != "" ]]; then
	local time=1
        printf "attaching to $detached; ctrl-c to cancel before "
		while [ $time -gt 0 ]; do
			printf "$time "
			time=$((time - 1))
			sleep 1
		done
		tmux attach -d -t "$detached"
    else
        tmux $@
    fi
}

pyloc() {
	pip show "$1" | grep Location | awk '{print $2}'
}

gpgself() {
    gpg --encrypt --recipient "matt.shen@sentrian.com" --output -
}

gzto() { 
    $1 | gzip - > $2
}
gunz() { unzip -c $1 ;}
unz() { gunzip -c $1 ;}

lastm() {
    # last modified time in find
    find $@ -print0 | xargs -0 stat --format '%Y' | sort --numeric --reverse | head -n 1
}

# OS X specific
if [[ "$(uname)" == "Darwin" ]]; then
        source_file_if_exists "${HOME}/.dotfiles/osx/bash-like-common/functions";
fi
